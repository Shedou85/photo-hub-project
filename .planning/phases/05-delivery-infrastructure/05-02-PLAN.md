---
phase: 05-delivery-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/collections/delivery.php
  - backend/helpers/download-tracker.php
  - backend/index.php
autonomous: true

must_haves:
  truths:
    - "Photographer can retrieve delivery token for a collection via API"
    - "Download tracking helper function exists and handles session-based deduplication"
    - "Download tracking gracefully handles duplicate key violations (returns false, does not error)"
    - "Delivery endpoint validates collection ownership and returns 404 for non-existent collections"
  artifacts:
    - path: "backend/collections/delivery.php"
      provides: "GET handler for delivery token retrieval"
      contains: "deliveryToken"
    - path: "backend/helpers/download-tracker.php"
      provides: "Reusable trackDownload() function with deduplication"
      contains: "trackDownload"
    - path: "backend/index.php"
      provides: "Route wiring for delivery endpoint"
      contains: "delivery"
  key_links:
    - from: "backend/index.php"
      to: "backend/collections/delivery.php"
      via: "require_once in router switch"
      pattern: "delivery\\.php"
    - from: "backend/helpers/download-tracker.php"
      to: "Download table"
      via: "INSERT with deduplication"
      pattern: "INSERT INTO.*Download"
---

<objective>
Create the delivery token retrieval API endpoint and a reusable download tracking helper function with session-based deduplication.

Purpose: The delivery endpoint allows the photographer to retrieve the delivery link info for a collection (consumed by the frontend in Phase 9 for "Copy Delivery Link" functionality). The download tracking helper is a shared utility that Phase 6 (ZIP downloads) and Phase 7 (individual downloads) will call to record download events without double-counting.

Output: New backend/collections/delivery.php handler, new backend/helpers/download-tracker.php utility, and updated backend/index.php router.
</objective>

<execution_context>
@C:/Users/Marius/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Marius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-infrastructure/05-RESEARCH.md
@.planning/phases/05-delivery-infrastructure/05-01-SUMMARY.md

@backend/index.php (router pattern and generateCuid() function)
@backend/collections/id.php (handler pattern reference)
@backend/collections/share.php (public endpoint pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delivery token retrieval endpoint and wire into router</name>
  <files>backend/collections/delivery.php, backend/index.php</files>
  <action>
**Step 1: Create backend/collections/delivery.php**

This is a GET endpoint at `/collections/{id}/delivery` that returns the delivery token for a collection. It follows the same pattern as `backend/collections/id.php` — authenticated, ownership-verified.

```php
<?php
require_once __DIR__ . '/../db.php';

session_start();

if (!isset($_SESSION['user_id'])) {
    http_response_code(401);
    echo json_encode(["error" => "Not authenticated"]);
    exit;
}

// Extract collection ID from URL: /collections/{id}/delivery
$requestUri = $_SERVER['REQUEST_URI'];
$requestUri = strtok($requestUri, '?');
$basePath = '/backend';
if (strpos($requestUri, $basePath) === 0) {
    $requestUri = substr($requestUri, strlen($basePath));
}
$requestUri = rtrim($requestUri, '/');
$parts = explode('/', ltrim($requestUri, '/'));
$collectionId = $parts[1] ?? '';

if (empty($collectionId)) {
    http_response_code(400);
    echo json_encode(["error" => "Collection ID is required."]);
    exit;
}

$userId = $_SESSION['user_id'];
$method = $_SERVER['REQUEST_METHOD'];

if ($method !== 'GET') {
    http_response_code(405);
    echo json_encode(["error" => "Method not allowed"]);
    exit;
}

try {
    $pdo = getDbConnection();

    // Verify ownership and fetch delivery info
    $stmt = $pdo->prepare("
        SELECT id, name, status, deliveryToken, shareId
        FROM `Collection`
        WHERE id = ? AND userId = ?
        LIMIT 1
    ");
    $stmt->execute([$collectionId, $userId]);
    $collection = $stmt->fetch(PDO::FETCH_ASSOC);

    if (!$collection) {
        http_response_code(404);
        echo json_encode(["error" => "Collection not found."]);
        exit;
    }

    // Return delivery info
    echo json_encode([
        "status" => "OK",
        "delivery" => [
            "collectionId" => $collection['id'],
            "collectionName" => $collection['name'],
            "collectionStatus" => $collection['status'],
            "deliveryToken" => $collection['deliveryToken'],
            "hasDeliveryToken" => !empty($collection['deliveryToken'])
        ]
    ]);

} catch (Throwable $e) {
    http_response_code(500);
    echo json_encode(["error" => "Server error", "details" => $e->getMessage()]);
}
```

**Step 2: Wire the delivery route into backend/index.php**

In the default case's `/collections/{id}` handler section (around line 201-226), add a new case for 'delivery' in the switch statement on `$subRoute`:

Add this case BEFORE the `default:` case in the sub-route switch:
```php
case 'delivery':
    require_once __DIR__ . '/collections/delivery.php';
    break;
```

This follows the exact same pattern as existing sub-routes ('photos', 'cover', 'selections', 'edited').
  </action>
  <verify>
1. Read backend/collections/delivery.php and confirm it:
   - Starts session and checks authentication
   - Extracts collectionId from URL
   - Verifies ownership (userId match)
   - Returns deliveryToken, hasDeliveryToken, collectionName, collectionStatus
   - Returns 404 for non-existent collections, 401 for unauthenticated, 405 for wrong method
2. Read backend/index.php and confirm 'delivery' case exists in the sub-route switch
  </verify>
  <done>GET /collections/{id}/delivery endpoint returns delivery token info with ownership verification, and route is wired into the router alongside existing sub-routes</done>
</task>

<task type="auto">
  <name>Task 2: Create reusable download tracking helper with session-based deduplication</name>
  <files>backend/helpers/download-tracker.php</files>
  <action>
Create a new directory `backend/helpers/` and file `backend/helpers/download-tracker.php` containing a reusable `trackDownload()` function.

This function will be called by Phase 6 (ZIP download endpoint) and Phase 7 (individual download endpoint) before streaming file data to the client. It must:

1. Accept parameters: `$pdo` (PDO connection), `$collectionId`, `$downloadType` ('ZIP' or 'INDIVIDUAL'), `$photoId` (null for ZIP)
2. Use PHP `session_id()` for session-based tracking
3. Bucket the timestamp to nearest hour for deduplication window
4. Use `generateCuid()` for the download record ID
5. Attempt INSERT into Download table
6. Catch duplicate key violation (PDOException code 23000) gracefully — return false
7. Return true for new downloads, false for duplicates
8. Never throw exceptions — download tracking must not block the actual file download

```php
<?php
/**
 * Download tracking helper with session-based deduplication.
 *
 * Tracks download events in the Download table. Uses a composite UNIQUE key
 * (collectionId, downloadType, sessionId, downloadedAt) to prevent double-counting
 * from browser resume requests within the same hour.
 *
 * Usage (in download endpoints):
 *   require_once __DIR__ . '/../helpers/download-tracker.php';
 *   $isNew = trackDownload($pdo, $collectionId, 'ZIP');
 *   // Continue with file download regardless of tracking result
 */

/**
 * Track a download event with session-based deduplication.
 *
 * @param PDO $pdo Database connection
 * @param string $collectionId Collection ID (CUID)
 * @param string $downloadType 'ZIP' or 'INDIVIDUAL'
 * @param string|null $photoId EditedPhoto ID for individual downloads (null for ZIP)
 * @return bool True if new download tracked, false if duplicate or error
 */
function trackDownload($pdo, $collectionId, $downloadType, $photoId = null) {
    // Ensure session is started for session_id()
    if (session_status() === PHP_SESSION_NONE) {
        session_start();
    }
    $sessionId = session_id();

    // Bucket timestamp to nearest hour for deduplication window
    // Same session + same collection + same type + same hour = duplicate
    $bucketedTime = date('Y-m-d H:00:00', time());

    try {
        $stmt = $pdo->prepare("
            INSERT INTO `Download` (id, collectionId, downloadType, photoId, sessionId, downloadedAt, userAgent, createdAt)
            VALUES (?, ?, ?, ?, ?, ?, ?, NOW(3))
        ");

        // Generate CUID for download record
        // Re-implement inline to avoid dependency on index.php's generateCuid()
        $timestamp = round(microtime(true) * 1000);
        $random = bin2hex(random_bytes(8));
        $counter = uniqid();
        $downloadId = 'cl' . substr(md5($timestamp . $random . $counter), 0, 22);

        $userAgent = substr($_SERVER['HTTP_USER_AGENT'] ?? '', 0, 500);

        $stmt->execute([
            $downloadId,
            $collectionId,
            $downloadType,
            $photoId,
            $sessionId,
            $bucketedTime,
            $userAgent ?: null
        ]);

        return true; // New download tracked

    } catch (\PDOException $e) {
        // Duplicate key violation (MySQL error code 23000) = expected duplicate
        if ($e->getCode() == 23000) {
            return false; // Resume request or duplicate within same hour
        }

        // Unexpected error: log but don't block download
        error_log("Download tracking error: " . $e->getMessage());
        return false;
    }
}
```

Key implementation notes:
- The function re-implements generateCuid() inline to avoid requiring index.php (which would execute routing logic). This follows the same 'cl' + md5 pattern from index.php.
- `session_start()` is only called if session isn't already active (idempotent).
- `userAgent` is truncated to 500 chars to match VARCHAR(500) column.
- The function NEVER throws — it catches all exceptions and returns false. Download endpoints must always proceed to send the file regardless of tracking success.
- Hour-level bucketing means a client who downloads at 2:59 PM and re-downloads at 3:01 PM gets two records. This is acceptable per research (different hour = potentially different visit).
  </action>
  <verify>
1. Confirm backend/helpers/ directory exists with download-tracker.php
2. Read the file and verify:
   - Function signature: `trackDownload($pdo, $collectionId, $downloadType, $photoId = null)`
   - Session handling: checks session_status(), starts if needed, uses session_id()
   - Time bucketing: `date('Y-m-d H:00:00', time())`
   - CUID generation: inline, same pattern as index.php
   - INSERT uses all 8 columns of Download table
   - Catches PDOException with code 23000 for duplicates
   - Returns bool (true = new, false = duplicate or error)
   - Never throws exceptions
  </verify>
  <done>Reusable trackDownload() helper function exists at backend/helpers/download-tracker.php with session-based deduplication, hour-level time bucketing, and graceful error handling — ready for Phase 6 and Phase 7 to consume</done>
</task>

</tasks>

<verification>
1. GET /collections/{id}/delivery returns delivery token info for authenticated owner
2. Route wired in backend/index.php under the /collections/{id} sub-route switch
3. backend/helpers/download-tracker.php contains trackDownload() function
4. trackDownload() uses session_id() + hour bucketing for deduplication
5. trackDownload() catches duplicate key violations gracefully
6. trackDownload() never throws exceptions
</verification>

<success_criteria>
- GET /collections/{id}/delivery returns 200 with deliveryToken info for valid owner
- GET /collections/{id}/delivery returns 404 for non-existent collection or wrong owner
- GET /collections/{id}/delivery returns 401 for unauthenticated request
- trackDownload() returns true for first download in a session/hour window
- trackDownload() returns false for duplicate download (same session + collection + type + hour)
- trackDownload() does not throw exceptions regardless of input
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-infrastructure/05-02-SUMMARY.md`
</output>
