---
phase: 05-delivery-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database_schema.sql
  - backend/collections/id.php
autonomous: true

must_haves:
  truths:
    - "Collection table has deliveryToken column with UNIQUE constraint"
    - "Download table exists with session-based deduplication schema (composite UNIQUE key)"
    - "Delivery token is automatically generated when collection transitions to DELIVERED status"
    - "GET /collections/{id} returns deliveryToken field in response"
  artifacts:
    - path: "database_schema.sql"
      provides: "Updated schema with deliveryToken column and Download table"
      contains: "deliveryToken"
    - path: "backend/collections/id.php"
      provides: "Auto-generate deliveryToken on DELIVERED transition + return in GET"
      contains: "random_bytes"
  key_links:
    - from: "backend/collections/id.php"
      to: "Collection.deliveryToken"
      via: "PATCH handler status transition"
      pattern: "deliveryToken.*random_bytes"
    - from: "backend/collections/id.php"
      to: "Collection table"
      via: "GET handler returns deliveryToken"
      pattern: "deliveryToken.*SELECT"
---

<objective>
Add delivery token column to Collection table, create Download tracking table, and hook auto-generation of delivery tokens into the DELIVERED status transition in the existing PATCH handler.

Purpose: Establish the database foundation and core backend logic for the delivery system. The deliveryToken column enables separate delivery links (distinct from shareId), and the Download table provides session-based deduplication for tracking download events in future phases.

Output: Updated database_schema.sql with both schema changes, and modified backend/collections/id.php with auto-token generation and deliveryToken in GET responses.
</objective>

<execution_context>
@C:/Users/Marius/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Marius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery-infrastructure/05-RESEARCH.md

@database_schema.sql
@backend/collections/id.php
@backend/index.php (for generateCuid() function reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deliveryToken column and Download table to database schema</name>
  <files>database_schema.sql</files>
  <action>
Add two schema changes to database_schema.sql:

1. **Add `deliveryToken` column to Collection table:**
   - Add `deliveryToken` VARCHAR(191) NULL AFTER `shareId` in the CREATE TABLE statement
   - Add `UNIQUE KEY Collection_deliveryToken_key (deliveryToken)` to the keys section
   - This is a nullable column because collections in DRAFT/SELECTING/REVIEWING status won't have a delivery token yet

2. **Create Download tracking table** (add after the PromotionalPhoto table):
   ```sql
   CREATE TABLE `Download` (
     `id` VARCHAR(191) NOT NULL,
     `collectionId` VARCHAR(191) NOT NULL,
     `downloadType` ENUM('ZIP', 'INDIVIDUAL') NOT NULL,
     `photoId` VARCHAR(191) NULL,
     `sessionId` VARCHAR(191) NOT NULL,
     `downloadedAt` DATETIME(3) NOT NULL,
     `userAgent` VARCHAR(500) NULL,
     `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
     PRIMARY KEY (`id`),
     KEY `Download_collectionId_idx` (`collectionId`),
     UNIQUE KEY `Download_deduplication_key` (`collectionId`, `downloadType`, `sessionId`, `downloadedAt`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
   ```

3. **Add foreign key constraints for Download table** (in the constraints section):
   ```sql
   ALTER TABLE `Download`
     ADD CONSTRAINT `Download_collectionId_fkey`
       FOREIGN KEY (`collectionId`) REFERENCES `Collection` (`id`)
       ON DELETE CASCADE ON UPDATE CASCADE,
     ADD CONSTRAINT `Download_photoId_fkey`
       FOREIGN KEY (`photoId`) REFERENCES `EditedPhoto` (`id`)
       ON DELETE SET NULL ON UPDATE CASCADE;
   ```

4. **Add migration comment at bottom** for existing databases:
   ```sql
   -- Migration: Add deliveryToken to Collection table (run on existing databases)
   -- ALTER TABLE `Collection` ADD COLUMN `deliveryToken` VARCHAR(191) NULL AFTER `shareId`;
   -- ALTER TABLE `Collection` ADD UNIQUE KEY `Collection_deliveryToken_key` (`deliveryToken`);
   --
   -- Migration: Create Download table (run on existing databases)
   -- (Run the full CREATE TABLE and ALTER TABLE statements above)
   ```

Key design decisions from research:
- `photoId` is NULL for ZIP downloads, references EditedPhoto for individual downloads
- `sessionId` stores PHP session_id() value (GDPR compliant, no IP tracking)
- `downloadedAt` will be bucketed to nearest hour in application code for deduplication
- Composite UNIQUE key `(collectionId, downloadType, sessionId, downloadedAt)` enforces deduplication at database level
- `photoId` FK uses ON DELETE SET NULL (preserve download records even if photo is removed)
  </action>
  <verify>
Read the updated database_schema.sql and confirm:
1. Collection table includes `deliveryToken` VARCHAR(191) NULL column with UNIQUE KEY
2. Download table exists with all 8 columns, correct types, and composite UNIQUE KEY
3. Foreign key constraints reference Collection(id) and EditedPhoto(id)
4. Migration comments exist at the bottom
  </verify>
  <done>database_schema.sql contains deliveryToken column on Collection table with UNIQUE constraint, Download table with session-based deduplication composite key, proper foreign key constraints, and migration comments for existing databases</done>
</task>

<task type="auto">
  <name>Task 2: Auto-generate deliveryToken on DELIVERED status transition and include in GET response</name>
  <files>backend/collections/id.php</files>
  <action>
Modify backend/collections/id.php with two changes:

**Change 1: Add deliveryToken to GET response**

In the GET handler's SELECT query (around line 39), add `deliveryToken` to the selected columns:
```sql
SELECT id, name, status, clientName, clientEmail, shareId, deliveryToken, coverPhotoId, expiresAt, allowPromotionalUse, createdAt, updatedAt
```

Also update the same SELECT query in the PATCH handler's response (around line 112) to include `deliveryToken`.

**Change 2: Auto-generate deliveryToken when status transitions to DELIVERED**

In the PATCH handler, after the existing status validation block (around line 82-90), add auto-generation logic. The existing code structure is:

```php
if (array_key_exists('status', $data)) {
    if (!in_array($data['status'], $validStatuses, true)) {
        http_response_code(400);
        echo json_encode(["error" => "Invalid status value."]);
        exit;
    }
    $setParts[] = "`status` = ?";
    $params[] = $data['status'];
}
```

Replace with:
```php
if (array_key_exists('status', $data)) {
    if (!in_array($data['status'], $validStatuses, true)) {
        http_response_code(400);
        echo json_encode(["error" => "Invalid status value."]);
        exit;
    }

    // Auto-generate delivery token when transitioning to DELIVERED
    if ($data['status'] === 'DELIVERED') {
        $checkStmt = $pdo->prepare("SELECT deliveryToken FROM `Collection` WHERE id = ? LIMIT 1");
        $checkStmt->execute([$collectionId]);
        $existing = $checkStmt->fetch(PDO::FETCH_ASSOC);

        if (empty($existing['deliveryToken'])) {
            $deliveryToken = bin2hex(random_bytes(32));
            $setParts[] = "`deliveryToken` = ?";
            $params[] = $deliveryToken;
        }
    }

    $setParts[] = "`status` = ?";
    $params[] = $data['status'];
}
```

Key implementation notes:
- Uses `random_bytes(32)` for 256-bit cryptographic entropy (64-char hex string via bin2hex)
- Only generates token if one doesn't already exist (idempotent — re-transitioning to DELIVERED doesn't create a new token)
- Token is added to the same UPDATE query via $setParts/$params pattern (no separate query needed)
- No collision retry needed — 256-bit collision probability is astronomically low, and UNIQUE constraint provides database-level safety
  </action>
  <verify>
Read the updated backend/collections/id.php and confirm:
1. GET handler SELECT includes `deliveryToken` in column list
2. PATCH handler has `if ($data['status'] === 'DELIVERED')` block that checks for existing token and generates one if empty
3. Token generation uses `bin2hex(random_bytes(32))`
4. PATCH response SELECT also includes `deliveryToken`
5. The auto-generation is inside the existing `if (array_key_exists('status', $data))` block, before the status $setParts addition
  </verify>
  <done>Backend auto-generates a 64-character hex delivery token when collection transitions to DELIVERED status (only if no token exists yet), and both GET and PATCH responses include the deliveryToken field</done>
</task>

</tasks>

<verification>
1. database_schema.sql has deliveryToken on Collection table + Download table with deduplication key
2. backend/collections/id.php auto-generates deliveryToken on DELIVERED transition
3. GET /collections/{id} response includes deliveryToken field
4. PATCH /collections/{id} response includes deliveryToken field
5. Token generation uses cryptographically secure random_bytes(32)
6. Token generation is idempotent (doesn't overwrite existing tokens)
</verification>

<success_criteria>
- Collection table schema includes nullable deliveryToken VARCHAR(191) with UNIQUE constraint
- Download table exists with composite UNIQUE key for session-based deduplication
- Transitioning a collection to DELIVERED status auto-generates a 64-char hex delivery token
- Re-transitioning to DELIVERED does NOT regenerate the token
- GET and PATCH responses for /collections/{id} include deliveryToken
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery-infrastructure/05-01-SUMMARY.md`
</output>
