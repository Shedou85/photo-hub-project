---
phase: 06-server-side-zip-downloads
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/composer.json
  - backend/collections/zip-download.php
  - backend/index.php
autonomous: true

must_haves:
  truths:
    - "GET /deliver/{deliveryToken}/zip returns a valid ZIP file containing all edited photos for a DELIVERED collection"
    - "ZIP generation streams directly to browser without buffering entire archive in memory"
    - "Invalid or missing delivery token returns 404 JSON error (not a corrupted ZIP)"
    - "Non-DELIVERED collection returns 403 JSON error"
    - "Download event is tracked in Download table via trackDownload() helper"
    - "Missing files on disk are skipped (partial ZIP) rather than aborting the entire download"
  artifacts:
    - path: "backend/composer.json"
      provides: "ZipStream-PHP dependency declaration"
      contains: "maennchen/zipstream-php"
    - path: "backend/collections/zip-download.php"
      provides: "Streaming ZIP download handler"
      min_lines: 60
    - path: "backend/index.php"
      provides: "Router wiring for /deliver/{token}/zip public route"
      contains: "zip-download.php"
  key_links:
    - from: "backend/index.php"
      to: "backend/collections/zip-download.php"
      via: "require_once in /deliver/ route handler"
      pattern: "zip-download\\.php"
    - from: "backend/collections/zip-download.php"
      to: "backend/helpers/download-tracker.php"
      via: "require_once and trackDownload() call"
      pattern: "trackDownload"
    - from: "backend/collections/zip-download.php"
      to: "ZipStream\\ZipStream"
      via: "Composer autoload and use statement"
      pattern: "use ZipStream\\\\ZipStream"
---

<objective>
Create the streaming ZIP download endpoint that serves all edited photos in a collection as a single ZIP file, accessible via delivery token (public, no authentication required).

Purpose: This is the core download capability for Phase 6 — clients receive a delivery link and can download all their edited photos as one ZIP archive. The streaming architecture ensures it works within Hostinger's 180s execution time and memory limits for collections with 100+ photos at 10MB each.

Output: Working ZIP download endpoint at `/deliver/{deliveryToken}/zip` with download tracking integration.
</objective>

<execution_context>
@C:/Users/Marius/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Marius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-server-side-zip-downloads/06-RESEARCH.md
@.planning/phases/05-delivery-infrastructure/05-01-SUMMARY.md
@.planning/phases/05-delivery-infrastructure/05-02-SUMMARY.md
@backend/index.php
@backend/composer.json
@backend/helpers/download-tracker.php
@backend/utils.php
@backend/cors.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ZipStream-PHP dependency and create streaming ZIP download handler</name>
  <files>
    backend/composer.json
    backend/collections/zip-download.php
  </files>
  <action>
**Step 1: Update composer.json** to add ZipStream-PHP 3.x dependency.

Add `"maennchen/zipstream-php": "^3.0"` to the `require` section of `backend/composer.json`. Keep the existing `nelmio/cors-bundle` dependency. Run `composer install` or `composer update` from the `backend/` directory to install the package and generate `vendor/autoload.php`. If Composer is not available locally, just update `composer.json` — the executor on Hostinger will run `composer install`.

**Step 2: Create `backend/collections/zip-download.php`** — the streaming ZIP endpoint.

This is a PUBLIC endpoint (no session/auth required). It authenticates via delivery token in the URL.

Implementation requirements:
1. **Require dependencies:** `vendor/autoload.php`, `db.php`, `helpers/download-tracker.php`
2. **Extract delivery token from URL** using `parseRouteParts()` from `utils.php`. The route is `/deliver/{deliveryToken}/zip` — token is at parts index 1. Also require `utils.php`.
3. **Validate delivery token** — return 400 JSON if empty
4. **Method check** — only allow GET, return 405 JSON otherwise
5. **Verify delivery token** — query Collection table WHERE deliveryToken = ?, return 404 JSON if not found
6. **Check collection status** — must be DELIVERED, return 403 JSON if not
7. **Fetch edited photos** — SELECT id, filename, storagePath FROM EditedPhoto WHERE collectionId = ?, ORDER BY filename ASC. Return 404 JSON if no photos found.
8. **Track download** — call `trackDownload($pdo, $collectionId, 'ZIP', null)` BEFORE streaming begins (while we can still send JSON errors). Log result via error_log.
9. **Disable output buffering** — `while (ob_get_level() > 0) ob_end_clean();`
10. **Configure PHP for streaming:** `ini_set('display_errors', 0)`, `set_time_limit(180)`, `ignore_user_abort(true)`, `ini_set('zlib.output_compression', 0)`
11. **Sanitize collection name** for ZIP filename — strip non-ASCII-safe characters with `preg_replace('/[^A-Za-z0-9_\-\. ]/', '', $collectionName)`, fallback to 'collection' if empty
12. **Initialize ZipStream** with `outputName`, `sendHttpHeaders: true`, `enableZip64: true`, `compressionMethod: CompressionMethod::STORE` (JPEGs are already compressed; STORE avoids CPU overhead and reduces time-per-file)
13. **Add extra headers** after ZipStream init: `Accept-Ranges: bytes` and `X-Accel-Buffering: no` (for Nginx reverse proxy compatibility)
14. **Stream each photo** — loop through photos, verify `file_exists()`, skip missing files with `error_log()`, call `$zip->addFileFromPath(fileName: $photo['filename'], path: $filePath)`. Track `$filesAdded` count.
15. **Finalize** — `$zip->finish()` then `exit;` (CRITICAL: no PHP closing tag `?>`, no output after finish)
16. **Error handling** — wrap ZipStream operations in try-catch. Before streaming starts, errors return JSON. After streaming starts (headers sent), errors are logged only.

Do NOT include a PHP closing tag `?>` at end of file (prevents accidental whitespace corruption).
  </action>
  <verify>
1. `backend/composer.json` contains `maennchen/zipstream-php` in require section
2. `backend/collections/zip-download.php` exists and contains:
   - `use ZipStream\ZipStream` import
   - `use ZipStream\CompressionMethod` import
   - `require_once` for vendor/autoload.php, db.php, download-tracker.php, utils.php
   - `trackDownload()` call with 'ZIP' type
   - `while (ob_get_level() > 0)` output buffer clearing
   - `set_time_limit(180)`
   - `CompressionMethod::STORE`
   - `$zip->finish()` followed by `exit;`
   - No PHP closing tag `?>`
3. File has proper delivery token validation, status check (DELIVERED only), and error responses
  </verify>
  <done>
backend/composer.json declares ZipStream-PHP ^3.0 dependency. zip-download.php implements complete streaming ZIP generation with delivery token auth, DELIVERED status gate, download tracking, output buffer clearing, 180s time limit, STORE compression, and graceful error handling for missing files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire /deliver/{token}/zip public route into backend router</name>
  <files>
    backend/index.php
  </files>
  <action>
Add a new public route handler in `backend/index.php` for the `/deliver/` prefix, similar to the existing `/share/` prefix handler in the `default:` case.

**Location:** In the `default:` case block of the switch statement, BEFORE the `/collections/` handler (around line 200), add a new block:

```php
// Handle /deliver/ routes (public endpoints — delivery token auth)
if (strpos($requestUri, '/deliver/') === 0) {
    $uriParts = explode('/', ltrim($requestUri, '/'));
    // uriParts: ['deliver', deliveryToken, ?subRoute]
    $subRoute = $uriParts[2] ?? '';

    switch ($subRoute) {
        case 'zip':
            if ($requestMethod === 'GET') {
                require_once __DIR__ . '/collections/zip-download.php';
            } else {
                http_response_code(405);
                echo json_encode(['error' => 'Method Not Allowed']);
            }
            break;
        default:
            http_response_code(404);
            echo json_encode(['error' => 'Endpoint Not Found']);
    }
    break;
}
```

This creates the route pattern `/deliver/{deliveryToken}/zip` which maps to `zip-download.php`. The delivery token extraction happens inside `zip-download.php` using `parseRouteParts()`.

**Important:** Place this block AFTER the `/share/` handler and BEFORE the `/collections/` handler in the default case, so the route matching order is: `/share/` → `/deliver/` → `/collections/`.

The `/deliver/` route prefix is PUBLIC (no session_start, no auth check in router) — authentication is handled by delivery token verification inside the handler itself.
  </action>
  <verify>
1. `backend/index.php` contains a `/deliver/` route handler block in the default case
2. The handler dispatches `zip` sub-route to `collections/zip-download.php`
3. The handler returns 404 for unknown sub-routes under `/deliver/`
4. The handler returns 405 for non-GET methods on the zip route
5. Route placement: after `/share/` handler, before `/collections/` handler
  </verify>
  <done>
Router dispatches GET /deliver/{token}/zip to zip-download.php. Unknown /deliver/ sub-routes return 404. Non-GET methods return 405. Route is public (no session/auth in router).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Structural verification:**
   - `backend/composer.json` has ZipStream-PHP dependency
   - `backend/collections/zip-download.php` exists with streaming ZIP logic
   - `backend/index.php` routes `/deliver/{token}/zip` to the handler

2. **Code path verification:**
   - Invalid token → 404 JSON response (before any streaming)
   - Non-DELIVERED collection → 403 JSON response
   - No edited photos → 404 JSON response
   - Valid DELIVERED collection with photos → ZIP stream with correct Content-Type and Content-Disposition headers
   - Missing file on disk → logged and skipped, ZIP continues with remaining files

3. **Integration verification:**
   - `trackDownload()` called before streaming begins
   - ZipStream uses STORE compression (no CPU overhead for pre-compressed JPEGs)
   - Output buffering cleared before ZipStream initialization
   - `set_time_limit(180)` set for Hostinger compatibility
   - No PHP closing tag in zip-download.php
</verification>

<success_criteria>
1. GET /deliver/{validToken}/zip returns Content-Type: application/zip with streaming ZIP data
2. ZIP contains all EditedPhoto files for the collection, named by their original filename
3. Streaming architecture uses constant ~60KB memory regardless of collection size
4. Download tracking records ZIP download in Download table
5. Error cases (invalid token, wrong status, no photos) return proper JSON error responses before any streaming begins
</success_criteria>

<output>
After completion, create `.planning/phases/06-server-side-zip-downloads/06-01-SUMMARY.md`
</output>
