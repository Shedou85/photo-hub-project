---
phase: 07-individual-photo-downloads
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database_schema.sql
  - backend/collections/zip-download.php
  - backend/collections/photo-download.php
  - backend/index.php
  - frontend/src/utils/download.js
autonomous: true

must_haves:
  truths:
    - "Individual photo downloads via /deliver/{token}/photo/{photoId} return file with Content-Disposition attachment header"
    - "Collection transitions from DELIVERED to DOWNLOADED on first download (ZIP or individual)"
    - "Downloads work from both DELIVERED and DOWNLOADED collection statuses"
    - "Download tracking records individual downloads with downloadType=INDIVIDUAL and photoId populated"
    - "Frontend download utility triggers browser download via anchor-click pattern"
  artifacts:
    - path: "backend/collections/photo-download.php"
      provides: "Individual photo download endpoint with delivery token auth and download tracking"
      min_lines: 60
    - path: "frontend/src/utils/download.js"
      provides: "Reusable downloadPhoto() function for delivery page"
      exports: ["downloadPhoto"]
    - path: "database_schema.sql"
      provides: "DOWNLOADED status in Collection ENUM"
      contains: "DOWNLOADED"
  key_links:
    - from: "backend/collections/photo-download.php"
      to: "backend/helpers/download-tracker.php"
      via: "trackDownload() call before streaming"
      pattern: "trackDownload.*INDIVIDUAL"
    - from: "backend/index.php"
      to: "backend/collections/photo-download.php"
      via: "require_once in /deliver/ route handler"
      pattern: "case 'photo'"
    - from: "frontend/src/utils/download.js"
      to: "/deliver/{token}/photo/{photoId}"
      via: "anchor href construction"
      pattern: "deliver.*photo"
---

<objective>
Implement individual photo download capability: backend endpoint with delivery token auth, DOWNLOADED status transitions, and frontend download utility.

Purpose: Enable clients to download individual edited photos from the delivery page (Phase 8 will consume these). This completes the download infrastructure alongside Phase 6's ZIP downloads.

Output: Working photo download endpoint, DOWNLOADED status lifecycle, frontend download helper.
</objective>

<execution_context>
@C:/Users/Marius/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Marius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@backend/collections/zip-download.php
@backend/helpers/download-tracker.php
@backend/index.php
@backend/utils.php
@database_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DOWNLOADED status to Collection ENUM and fix ZIP download status gate</name>
  <files>database_schema.sql, backend/collections/zip-download.php</files>
  <action>
**1. Update database_schema.sql:**

Add 'DOWNLOADED' to the Collection status ENUM definition (line 80). Change:
```sql
`status` ENUM('DRAFT', 'SELECTING', 'REVIEWING', 'DELIVERED', 'ARCHIVED') NOT NULL DEFAULT 'DRAFT',
```
to:
```sql
`status` ENUM('DRAFT', 'SELECTING', 'REVIEWING', 'DELIVERED', 'DOWNLOADED', 'ARCHIVED') NOT NULL DEFAULT 'DRAFT',
```

Add a migration comment at the bottom of the file (following the existing migration comment pattern):
```sql
-- --------------------------------------------------------
--
-- Migration: Add DOWNLOADED status to Collection ENUM (run on existing databases)
--
-- ALTER TABLE `Collection` MODIFY COLUMN `status` ENUM('DRAFT', 'SELECTING', 'REVIEWING', 'DELIVERED', 'DOWNLOADED', 'ARCHIVED') NOT NULL DEFAULT 'DRAFT';
```

**2. Fix zip-download.php status gate:**

The current status check on line 52 only allows DELIVERED:
```php
if ($collection['status'] !== 'DELIVERED') {
```

Change it to allow both DELIVERED and DOWNLOADED (once a collection is downloaded, re-downloads must still work):
```php
if ($collection['status'] !== 'DELIVERED' && $collection['status'] !== 'DOWNLOADED') {
```

Also add the DOWNLOADED status transition logic after the trackDownload() call (around line 79), BEFORE the "POINT OF NO RETURN" comment. Add:
```php
// Transition to DOWNLOADED status on first download (idempotent)
if ($collection['status'] === 'DELIVERED') {
    $updateStmt = $pdo->prepare("
        UPDATE Collection
        SET status = 'DOWNLOADED', updatedAt = NOW(3)
        WHERE id = ? AND status = 'DELIVERED'
    ");
    $updateStmt->execute([$collectionId]);
    if ($updateStmt->rowCount() > 0) {
        error_log("Collection {$collectionId} transitioned to DOWNLOADED status via ZIP download");
    }
}
```

This uses conditional UPDATE with WHERE status='DELIVERED' to prevent race conditions. The rowCount() check handles concurrent requests gracefully.
  </action>
  <verify>
1. Verify database_schema.sql contains 'DOWNLOADED' in the Collection status ENUM
2. Verify zip-download.php allows both DELIVERED and DOWNLOADED statuses
3. Verify zip-download.php has DOWNLOADED status transition logic after trackDownload() call
4. Verify migration comment follows existing pattern at bottom of database_schema.sql
  </verify>
  <done>
Collection ENUM includes DOWNLOADED status. ZIP download endpoint allows downloads from both DELIVERED and DOWNLOADED collections. First ZIP download transitions collection to DOWNLOADED status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create individual photo download endpoint and wire router</name>
  <files>backend/collections/photo-download.php, backend/index.php</files>
  <action>
**1. Create backend/collections/photo-download.php:**

Follow the exact same pattern as zip-download.php (track-then-stream). The endpoint serves: GET /deliver/{deliveryToken}/photo/{photoId}

```php
<?php
/**
 * Individual photo download endpoint for delivery tokens.
 *
 * Route: GET /deliver/{deliveryToken}/photo/{photoId}
 * Auth: Public — delivery token verification
 * Returns: Single photo file with Content-Disposition attachment header
 */

require_once __DIR__ . '/../db.php';
require_once __DIR__ . '/../helpers/download-tracker.php';
require_once __DIR__ . '/../utils.php';

// Extract deliveryToken and photoId from route: /deliver/{deliveryToken}/photo/{photoId}
$routeParts = parseRouteParts();
// routeParts: ['deliver', deliveryToken, 'photo', photoId]
$deliveryToken = $routeParts[1] ?? '';
$photoId = $routeParts[3] ?? '';

if (empty($deliveryToken) || empty($photoId)) {
    http_response_code(400);
    echo json_encode(['error' => 'Delivery token and photo ID required']);
    exit;
}

if ($_SERVER['REQUEST_METHOD'] !== 'GET') {
    http_response_code(405);
    echo json_encode(['error' => 'Method Not Allowed']);
    exit;
}

try {
    $pdo = getDbConnection();

    // Verify delivery token and get collection
    $stmt = $pdo->prepare("SELECT id, status FROM Collection WHERE deliveryToken = ?");
    $stmt->execute([$deliveryToken]);
    $collection = $stmt->fetch(PDO::FETCH_ASSOC);

    if (!$collection) {
        http_response_code(404);
        echo json_encode(['error' => 'Collection not found']);
        exit;
    }

    // Allow downloads from DELIVERED and DOWNLOADED statuses
    if ($collection['status'] !== 'DELIVERED' && $collection['status'] !== 'DOWNLOADED') {
        http_response_code(403);
        echo json_encode(['error' => 'Collection not available for download']);
        exit;
    }

    $collectionId = $collection['id'];

    // Fetch the specific edited photo
    $stmt = $pdo->prepare("
        SELECT id, filename, storagePath
        FROM EditedPhoto
        WHERE id = ? AND collectionId = ?
        LIMIT 1
    ");
    $stmt->execute([$photoId, $collectionId]);
    $photo = $stmt->fetch(PDO::FETCH_ASSOC);

    if (!$photo) {
        http_response_code(404);
        echo json_encode(['error' => 'Photo not found']);
        exit;
    }

    $filePath = __DIR__ . '/../' . $photo['storagePath'];

    if (!file_exists($filePath)) {
        http_response_code(404);
        echo json_encode(['error' => 'Photo file not found on disk']);
        exit;
    }

    // Track download BEFORE streaming (while we can still send JSON errors)
    $isNewDownload = trackDownload($pdo, $collectionId, 'INDIVIDUAL', $photoId);
    error_log("Individual photo download: collection={$collectionId}, photo={$photoId}, new=" . ($isNewDownload ? 'true' : 'false'));

    // Transition to DOWNLOADED status on first download (idempotent)
    if ($collection['status'] === 'DELIVERED') {
        $updateStmt = $pdo->prepare("
            UPDATE Collection
            SET status = 'DOWNLOADED', updatedAt = NOW(3)
            WHERE id = ? AND status = 'DELIVERED'
        ");
        $updateStmt->execute([$collectionId]);
        if ($updateStmt->rowCount() > 0) {
            error_log("Collection {$collectionId} transitioned to DOWNLOADED status via individual download");
        }
    }

    // --- POINT OF NO RETURN: Headers will be sent ---

    // Disable output buffering
    while (ob_get_level() > 0) {
        ob_end_clean();
    }

    // Send download headers
    $safeFilename = $photo['filename'];
    $fileSize = filesize($filePath);
    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $mimeType = finfo_file($finfo, $filePath) ?: 'application/octet-stream';
    finfo_close($finfo);

    header('Content-Type: ' . $mimeType);
    header('Content-Disposition: attachment; filename="' . addslashes($safeFilename) . '"');
    header('Content-Length: ' . $fileSize);
    header('Content-Transfer-Encoding: binary');
    header('Accept-Ranges: bytes');
    header('Cache-Control: no-cache, no-store, must-revalidate');
    header('Pragma: no-cache');
    header('Expires: 0');

    // Stream file to browser (memory-efficient, 8KB chunks)
    readfile($filePath);

} catch (\Exception $e) {
    if (!headers_sent()) {
        http_response_code(500);
        echo json_encode(['error' => 'Download failed: ' . $e->getMessage()]);
    } else {
        error_log("Photo download error after streaming started: " . $e->getMessage());
    }
}

exit;
```

**2. Wire route in backend/index.php:**

In the existing `/deliver/` route handler (around line 206), add a new case for 'photo' BEFORE the `default:` case:

```php
case 'photo':
    if ($requestMethod === 'GET') {
        require_once __DIR__ . '/collections/photo-download.php';
    } else {
        http_response_code(405);
        echo json_encode(['error' => 'Method Not Allowed']);
    }
    break;
```

This follows the exact same pattern as the existing 'zip' case.
  </action>
  <verify>
1. Verify backend/collections/photo-download.php exists and follows track-then-stream pattern
2. Verify it requires download-tracker.php and calls trackDownload() with 'INDIVIDUAL' type and photoId
3. Verify Content-Disposition: attachment header is sent
4. Verify output buffering is cleared before readfile()
5. Verify finfo_file() is used for MIME type detection (not extension-based)
6. Verify backend/index.php has case 'photo' in /deliver/ route handler
7. Verify the photo case dispatches to collections/photo-download.php
  </verify>
  <done>
Individual photo download endpoint responds at /deliver/{token}/photo/{photoId}. Returns photo file with Content-Disposition attachment header. Tracks downloads as INDIVIDUAL type with photoId. Transitions DELIVERED to DOWNLOADED on first download. Router dispatches GET requests to handler.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create frontend download utility</name>
  <files>frontend/src/utils/download.js</files>
  <action>
Create the `frontend/src/utils/` directory and `download.js` file. This utility will be consumed by Phase 8's delivery page.

```javascript
/**
 * Download utilities for delivery page.
 *
 * Uses server-side Content-Disposition headers for cross-browser downloads.
 * No file-saver library needed — server controls download behavior via headers.
 */

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

/**
 * Trigger individual photo download via server endpoint.
 *
 * Creates a temporary anchor element and programmatically clicks it.
 * The server endpoint sends Content-Disposition: attachment header,
 * which triggers the browser download dialog regardless of cross-origin restrictions.
 *
 * @param {string} deliveryToken - Collection delivery token
 * @param {string} photoId - EditedPhoto ID (CUID)
 * @param {string} filename - Original photo filename (for download attribute fallback)
 */
export function downloadPhoto(deliveryToken, photoId, filename) {
  const downloadUrl = `${API_BASE_URL}/deliver/${deliveryToken}/photo/${photoId}`;

  const link = document.createElement('a');
  link.href = downloadUrl;
  link.download = filename; // Fallback filename (server header takes precedence)
  link.style.display = 'none';

  // Append to DOM (required for Firefox compatibility)
  document.body.appendChild(link);
  link.click();

  // Cleanup
  document.body.removeChild(link);
}

/**
 * Trigger ZIP download of all photos via server endpoint.
 *
 * @param {string} deliveryToken - Collection delivery token
 */
export function downloadAllAsZip(deliveryToken) {
  const downloadUrl = `${API_BASE_URL}/deliver/${deliveryToken}/zip`;

  const link = document.createElement('a');
  link.href = downloadUrl;
  link.download = ''; // Let server Content-Disposition header set filename
  link.style.display = 'none';

  document.body.appendChild(link);
  link.click();

  document.body.removeChild(link);
}
```

Note: Both functions use the anchor-click pattern (no fetch/blob needed) because the server sends Content-Disposition: attachment headers. This works cross-browser (Chrome 65+, Firefox 20+, Safari 10.1+) without any library dependency.

The `downloadAllAsZip` function is included as a convenience wrapper for Phase 8's delivery page, keeping all download logic in one utility file.
  </action>
  <verify>
1. Verify frontend/src/utils/download.js exists
2. Verify it exports downloadPhoto() and downloadAllAsZip() functions
3. Verify it uses import.meta.env.VITE_API_BASE_URL for API base URL
4. Verify anchor-click pattern: createElement('a'), set href, appendChild, click(), removeChild
5. Verify no fetch/blob workaround (unnecessary with server Content-Disposition headers)
6. Run `cd frontend && npx eslint src/utils/download.js` to check for lint errors
  </verify>
  <done>
Frontend download utility exports downloadPhoto() and downloadAllAsZip(). Both use anchor-click pattern with server Content-Disposition headers. No external dependencies. Ready for Phase 8 delivery page consumption.
  </done>
</task>

</tasks>

<verification>
**Structural checks:**
- [ ] database_schema.sql Collection ENUM includes DOWNLOADED
- [ ] backend/collections/photo-download.php exists (60+ lines)
- [ ] frontend/src/utils/download.js exists with downloadPhoto and downloadAllAsZip exports
- [ ] backend/index.php routes /deliver/{token}/photo/{photoId} to photo-download.php

**Integration checks:**
- [ ] photo-download.php calls trackDownload($pdo, $collectionId, 'INDIVIDUAL', $photoId)
- [ ] photo-download.php sends Content-Disposition: attachment header
- [ ] photo-download.php clears output buffering before readfile()
- [ ] photo-download.php uses finfo_file() for MIME type detection
- [ ] zip-download.php allows DOWNLOADED status (not just DELIVERED)
- [ ] zip-download.php transitions DELIVERED to DOWNLOADED on first download
- [ ] Both download endpoints use conditional UPDATE with WHERE status='DELIVERED' for race safety

**Frontend checks:**
- [ ] download.js uses VITE_API_BASE_URL environment variable
- [ ] download.js uses anchor-click pattern (no fetch/blob)
- [ ] ESLint passes on download.js
</verification>

<success_criteria>
1. GET /deliver/{validToken}/photo/{validPhotoId} returns photo file with Content-Disposition: attachment
2. Invalid token returns 404, non-DELIVERED/DOWNLOADED collection returns 403, missing photo returns 404
3. Download table gets new INDIVIDUAL record with photoId populated
4. Collection transitions DELIVERED to DOWNLOADED on first download (ZIP or individual)
5. Subsequent downloads from DOWNLOADED status still work (both ZIP and individual)
6. Frontend download.js exports working downloadPhoto() and downloadAllAsZip() functions
</success_criteria>

<output>
After completion, create `.planning/phases/07-individual-photo-downloads/07-01-SUMMARY.md`
</output>
