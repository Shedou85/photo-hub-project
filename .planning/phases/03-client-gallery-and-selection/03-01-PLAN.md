---
phase: 03-client-gallery-and-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/collections/share-selections.php
  - backend/index.php
  - backend/collections/share.php
autonomous: true

must_haves:
  truths:
    - "GET /share/{shareId}/selections returns existing selections for a collection"
    - "POST /share/{shareId}/selections creates a selection (only when status is SELECTING)"
    - "DELETE /share/{shareId}/selections/{photoId} removes a selection (only when status is SELECTING)"
    - "POST/DELETE return 403 when collection status is not SELECTING"
    - "GET /share/{shareId} response includes selections array alongside photos"
    - "Invalid shareId returns 404 on all selection endpoints"
  artifacts:
    - path: "backend/collections/share-selections.php"
      provides: "Public selections CRUD endpoint (token-based, no session auth)"
      contains: "Selection"
    - path: "backend/index.php"
      provides: "Route registration for /share/{shareId}/selections"
      contains: "share-selections"
    - path: "backend/collections/share.php"
      provides: "Selections included in public share response"
      contains: "Selection"
  key_links:
    - from: "backend/index.php"
      to: "backend/collections/share-selections.php"
      via: "require_once in /share/ route handler"
      pattern: "share-selections\\.php"
    - from: "backend/collections/share-selections.php"
      to: "Selection table"
      via: "PDO prepared statements"
      pattern: "FROM.*Selection"
    - from: "backend/collections/share.php"
      to: "Selection table"
      via: "PDO query joining selections to collection"
      pattern: "Selection.*collectionId"
---

<objective>
Create the public selections API and extend the share endpoint to return existing selections.

Purpose: Clients need a backend to persist their photo selections without creating an account. The shareId token acts as authorization. Status gating ensures selections are only modifiable during SELECTING status.

Output: Three backend changes — new `share-selections.php` handler, route registration in `index.php`, and extended `share.php` to include selections in response.
</objective>

<execution_context>
@C:/Users/Marius/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Marius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/index.php
@backend/collections/share.php
@backend/collections/selections.php
@backend/utils.php
@backend/cors.php
@backend/db.php
@database_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public selections endpoint and register route</name>
  <files>backend/collections/share-selections.php, backend/index.php</files>
  <action>
Create `backend/collections/share-selections.php` — a PUBLIC endpoint (no session_start, no auth check) that handles GET/POST/DELETE for photo selections via shareId token.

**share-selections.php structure:**

1. `require_once __DIR__ . '/../db.php'` and `require_once __DIR__ . '/../utils.php'`
2. Parse route parts: `/share/{shareId}/selections[/{photoId}]` — shareId is `$parts[1]`, photoId is `$parts[3]` (for DELETE)
3. Validate shareId is not empty (400 if missing)
4. Query Collection by shareId to get `id` and `status` (404 if not found)
5. Handle methods:

**GET** — return all selections for the collection (no status gate — selections should be readable in REVIEWING too):
```php
SELECT id, photoId, createdAt FROM `Selection` WHERE collectionId = ? ORDER BY createdAt ASC
```
Return: `{ "status": "OK", "selections": [...] }`

**POST** — create a selection:
- Gate: `$collection['status'] !== 'SELECTING'` → 403 with `{ "error": "Selection not available for this collection" }`
- Read JSON body for `photoId`; validate not empty (400)
- Verify photo belongs to collection: `SELECT id FROM Photo WHERE id = ? AND collectionId = ?` (404 if not found)
- Use INSERT IGNORE or try/catch for duplicate key (Selection_photoId_key is UNIQUE — a photo can only be selected once). If duplicate, return 200 OK with existing selection data (idempotent).
- Generate CUID via `generateCuid()` (available from index.php — BUT since this is required via share route, `generateCuid()` is already defined in index.php which was loaded first). Insert into Selection table.
- Return: `{ "status": "OK", "selection": { "id": ..., "photoId": ..., "createdAt": ... } }`

**DELETE** — remove a selection:
- Gate: `$collection['status'] !== 'SELECTING'` → 403
- photoId from URL path (`$parts[3]`); validate not empty (400)
- DELETE FROM Selection WHERE collectionId = ? AND photoId = ?
- If rowCount() === 0 → 404
- Return: `{ "status": "OK" }`

**Other methods** → 405

**Register route in `backend/index.php`:**

In the `default:` block, the `/share/` handler currently matches all `/share/` URLs and requires GET. We need to update this to differentiate:
- `/share/{shareId}` (GET only) → share.php
- `/share/{shareId}/selections[/{photoId}]` (GET/POST/DELETE) → share-selections.php

Replace the existing `/share/` handler block with:
```php
if (strpos($requestUri, '/share/') === 0) {
    // Check if this is a selections sub-route: /share/{shareId}/selections[/{photoId}]
    if (preg_match('#^/share/[^/]+/selections#', $requestUri)) {
        if (in_array($requestMethod, ['GET', 'POST', 'DELETE'])) {
            require_once __DIR__ . '/collections/share-selections.php';
        } else {
            http_response_code(405);
            echo json_encode(['error' => 'Method Not Allowed']);
        }
        break;
    }
    // Base share route: /share/{shareId}
    if ($requestMethod === 'GET') {
        require_once __DIR__ . '/collections/share.php';
    } else {
        http_response_code(405);
        echo json_encode(['error' => 'Method Not Allowed']);
    }
    break;
}
```

**Important notes:**
- The selections sub-route check MUST come before the base share route check (more specific match first)
- `generateCuid()` is already defined in `index.php` (line 18), so it will be available in the required file
- Use `parseRouteParts()` from utils.php for consistent URL parsing
- All responses use `json_encode()` consistent with existing handlers
- Handle OPTIONS preflight via the existing cors.php (already loaded in index.php)
  </action>
  <verify>
1. Check PHP syntax: `php -l backend/collections/share-selections.php`
2. Verify route registration: grep for "share-selections" in backend/index.php
3. Verify share-selections.php uses parseRouteParts() and getDbConnection()
4. Verify no session_start() in share-selections.php (public endpoint)
  </verify>
  <done>
- share-selections.php exists with GET/POST/DELETE handlers
- Status gate returns 403 for POST/DELETE when status is not SELECTING
- GET returns selections without status gate
- Route registered in index.php with selections sub-route matched before base share route
- No session/auth required — shareId token is the sole authorization
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend share.php to include selections in response</name>
  <files>backend/collections/share.php</files>
  <action>
Extend the existing `backend/collections/share.php` GET endpoint to include an array of existing selections in the collection response. This avoids a separate API call on page load — the frontend gets everything it needs in one request.

After the photos query (line ~48-50), add a selections query:

```php
// Query selections for this collection
$stmt = $pdo->prepare("
    SELECT id, photoId, createdAt
    FROM `Selection`
    WHERE collectionId = ?
    ORDER BY createdAt ASC
");
$stmt->execute([$collection['id']]);
$selections = $stmt->fetchAll(PDO::FETCH_ASSOC);

// Attach selections to collection
$collection['selections'] = $selections;
```

Place this between the existing `$collection['photos'] = $photos;` line and the final `echo json_encode(...)` line.

This means the response shape becomes:
```json
{
  "status": "OK",
  "collection": {
    "id": "...",
    "name": "...",
    "status": "...",
    "photos": [...],
    "selections": [{ "id": "...", "photoId": "...", "createdAt": "..." }, ...]
  }
}
```

The frontend can initialize selectedPhotoIds from `collection.selections` on mount without a separate fetch.

**No status gate on this query** — selections should be visible regardless of collection status (e.g., photographer may have transitioned to REVIEWING and client refreshes the page — they should still see their selections, just not be able to modify them).
  </action>
  <verify>
1. Check PHP syntax: `php -l backend/collections/share.php`
2. Grep for "Selection" in share.php to confirm the query was added
3. Verify the selections array is attached before json_encode output
  </verify>
  <done>
- GET /share/{shareId} response now includes `collection.selections` array
- Selections are queried from Selection table by collectionId
- No status gate — selections are always included in response
- Response shape unchanged except for the new `selections` field
  </done>
</task>

</tasks>

<verification>
1. `php -l backend/collections/share-selections.php` — no syntax errors
2. `php -l backend/collections/share.php` — no syntax errors
3. Route in index.php: `/share/{shareId}/selections` maps to share-selections.php
4. share-selections.php: GET works without status gate, POST/DELETE gate on SELECTING
5. share.php: response includes `selections` array
6. No session_start() in share-selections.php
7. generateCuid() is available (defined in index.php, loaded before require)
</verification>

<success_criteria>
- Public selections API (GET/POST/DELETE) works via shareId token with no auth
- Status gating: POST/DELETE return 403 unless collection status is SELECTING
- Share endpoint response includes selections alongside photos
- All PHP files pass syntax check
- Consistent response patterns with existing backend handlers
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-gallery-and-selection/03-01-SUMMARY.md`
</output>
